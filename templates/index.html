<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D AI Dungeon</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            background: #1d1f21;
            color: #ffffff;
            font-family: 'Consolas', monospace;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background: #282a36;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,128,128,0.3);
        }
        
        .chat-window {
            height: 500px;
            border: 2px solid #61afef;
            padding: 15px;
            overflow-y: scroll;
            margin-bottom: 20px;
        }
        
        .message {
            margin: 10px 0;
        }
        
        .dm-message {
            color: #bd93f9;
        }
        
        .player-message {
            color: #50fa7b;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        input {
            flex: 1;
            padding: 10px;
            background: #2c2e32;
            border: 2px solid #44475a;
            color: #ffffff;
        }
        
        .action-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: white;
            transition: filter 0.3s;
        }
        
        .action-btn:hover {
            filter: brightness(1.2);
        }
        
        .copy-btn {
            background-color: #50fa7b;
            color: #282a36;
        }
        
        .send-btn {
            background-color: #61afef;
        }

        .error-message {
            color: #ff5555;
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .new-game-btn {
            background-color: #ff5555;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .new-game-btn:hover {
            background-color: #ff3333;
        }
        
        .session-info {
            font-size: 0.8em;
            color: #6272a4;
            text-align: center;
            margin-top: 10px;
        }

        .typing {
            font-style: italic;
            opacity: 0.7;
        }
        
        .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background-color: #bd93f9;
            animation: blink 1s infinite;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .session-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            background: #2c2e32;
            padding: 10px;
            border-radius: 4px;
        }
        
        .session-id-display {
            font-family: monospace;
            color: #8be9fd;
        }
        
        .session-join {
            display: flex;
            gap: 5px;
        }
        
        .session-join input {
            width: 150px;
        }
        
        .join-btn {
            background-color: #61afef;
            color: white;
        }
        
        .player-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .player-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .player-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .player-label {
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-weight: bold;
            color: #50fa7b;
        }
        
        .buttons-container {
            display: flex;
            justify-content: flex-end; /* Align to the right */
            gap: 10px;
            margin-top: 10px;
        }
        
        .copy-btn {
            background-color: #50fa7b;
            color: #282a36;
            width: auto; /* Make it auto width */
        }

        /* Add this style for proper text formatting */
        .message-content {
            white-space: pre-wrap; /* This preserves whitespace and enables wrapping */
        }

        .session-footer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            background: #2c2e32;
            padding: 10px;
            border-radius: 4px;
            gap: 10px;
        }
        
        .session-info {
            font-size: 0.9em;
            color: #8be9fd;
            text-align: center;
        }
        
        .session-details {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .session-id {
            font-family: monospace;
            color: #8be9fd;
        }
        
        .session-join {
            display: flex;
            gap: 5px;
        }
        
        .session-join input {
            width: 150px;
        }

        /* Remove the now-unused session-controls styles */
        .session-controls {
            display: none; /* Hide the old container */
        }

        /* Update session footer styles */
        .session-footer {
            display: flex;
            align-items: center;
            margin-top: 10px;
            background: #2c2e32;
            padding: 10px;
            border-radius: 4px;
        }
        
        .session-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .session-info-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .session-info {
            font-size: 0.9em;
            color: #8be9fd;
        }
        
        .separator {
            color: #6272a4;
        }
        
        .buttons-container {
            display: flex;
            justify-content: space-between; /* Space between add and copy buttons */
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .spacer {
            flex: 1; /* This pushes the copy button to the right */
        }

        /* Updated buttons container for just the copy button */
        .buttons-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
        }
        
        /* Keep only the copy button styles */
        .copy-btn {
            background-color: #50fa7b;
            color: #282a36;
            width: auto;
        }

        /* Add style for the Add Player button */
        .add-player-btn {
            background-color: #ff79c6;
            color: #282a36;
        }
        
        /* This class is used to hide elements */
        .hidden {
            display: none;
        }
        
        /* Update buttons container to show both buttons properly */
        .buttons-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .spacer {
            flex: 1; /* This pushes the copy button to the right */
        }

        /* Add style for clickable session ID */
        .clickable {
            cursor: pointer;
        }
        .clickable:hover {
            text-decoration: underline;
        }
        
        /* Show the session footer again */
        .session-footer {
            display: flex;
            align-items: center;
            margin-top: 10px;
            background: #2c2e32;
            padding: 10px;
            border-radius: 4px;
        }

        /* Remove all session footer related styles */
        .session-footer, .session-details, .session-info-container,
        .session-id-display, .session-join, .separator, .clickable {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container">
            <h1 style="color: #8be9fd;">ðŸ§™ AI Dungeon Master</h1>
            <button id="new-game-btn" class="new-game-btn">New Game</button>
        </div>
        
        <div class="chat-window" id="chat-window"></div>
        
        <div class="player-inputs">
            <div class="player-input">
                <div class="player-label" id="player1-label">Player 1:</div>
                <input 
                    type="text" 
                    id="user-input" 
                    placeholder="Type your message..." 
                    autocomplete="off"
                    class="player1-input"
                >
                <button id="send-btn" class="action-btn send-btn" title="Send message">
                    ðŸ“¤ Send
                </button>
            </div>
            
            <!-- Add Player 2 container (hidden by default) -->
            <div class="player-input hidden" id="player2-container">
                <div class="player-label" id="player2-label">Player 2:</div>
                <input 
                    type="text" 
                    id="player2-input" 
                    placeholder="Type your message..." 
                    autocomplete="off"
                    class="player2-input"
                >
                <button id="send-player2-btn" class="action-btn send-btn" title="Send message">
                    ðŸ“¤ Send
                </button>
            </div>
            
            <div id="additional-players"></div>
            
            <div class="buttons-container">
                <button id="add-player-btn" class="action-btn add-player-btn" title="Add another player">
                    ðŸ‘¤+ Add Player
                </button>
                <div class="spacer"></div>
                <button id="copy-chat-btn" class="action-btn copy-btn" title="Copy entire chat">
                    ðŸ“‹ Copy
                </button>
            </div>
        </div>
        
        <!-- Remove the session footer element completely -->
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Debug setup
    const DEBUG = true;
    function debugLog(...args) {
        if (DEBUG) console.log(...args);
    }
    
    debugLog("=== CLEAN INITIALIZATION STARTED ===");
    
    // Core variables
    let isGenerating = false;
    let awaitingName = true;
    let playerName = null;
    let seenMessages = new Set();
    
    // Session data - just store game ID locally
    let currentGameId = localStorage.getItem('currentGameId') || null;
    
    // Player tracking - IMPORTANT: Use let instead of const to allow reassignment
    let playerNames = loadPlayerNames();
    
    // Track processed messages to avoid duplicates
    const processedMessageIds = new Set();
    
    // Keep track of last message from each player to avoid duplicates
    const lastPlayerMessages = {};
    
    // Get DOM elements once
    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const newGameBtn = document.getElementById('new-game-btn');
    const sendBtn = document.getElementById('send-btn');
    const copyChatBtn = document.getElementById('copy-chat-btn');
    const player2Container = document.getElementById('player2-container');
    const player2Input = document.getElementById('player2-input');
    const sendPlayer2Btn = document.getElementById('send-player2-btn');
    const addPlayerBtn = document.getElementById('add-player-btn');
    const additionalPlayersContainer = document.getElementById('additional-players');
    let nextPlayerNumber = 3; // Start with player 3 since we already have 1 and 2
    
    // Add variables for update polling
    let lastMessageCount = 0;
    let updateCheckInterval = null;
    let isCheckingForUpdates = false;
    let lastSentMessage = "";
    
    // Flag to control automatic polling - set to false to completely disable updates
    let enableAutomaticPolling = false;
    
    // Functions for saving/loading player names from localStorage
    function savePlayerNames() {
        localStorage.setItem('playerNames', JSON.stringify(playerNames));
        debugLog("Player names saved:", playerNames);
    }
    
    function loadPlayerNames() {
        try {
            const saved = localStorage.getItem('playerNames');
            if (saved) {
                return JSON.parse(saved);
            }
        } catch (e) {
            debugLog("Error loading player names:", e);
        }
        return { 1: null, 2: null };
    }
    
    // Update updatePlayerLabel to save to localStorage
    function updatePlayerLabel(playerNumber, name) {
        debugLog(`Updating Player ${playerNumber} label to ${name}`);
        
        const labelElement = document.getElementById(`player${playerNumber}-label`);
        if (labelElement) {
            labelElement.textContent = `${name}:`;
            playerNames[playerNumber] = name;
            
            // Save to localStorage whenever a name is updated
            savePlayerNames();
        }
    }

    function createLoadingDivForDM(id, textId) {
        debugLog("Creating loading div:", id, textId);
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'message dm-message';
        loadingDiv.id = id;
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = 'DM: ';
        nameSpan.style.fontWeight = 'bold';
        
        const responseText = document.createElement('span');
        responseText.id = textId || 'response-text';
        responseText.className = 'typing message-content';
        responseText.textContent = '';
        
        const cursor = document.createElement('span');
        cursor.className = 'cursor';
        responseText.appendChild(cursor);
        
        loadingDiv.appendChild(nameSpan);
        loadingDiv.appendChild(responseText);
        chatWindow.appendChild(loadingDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        
        return loadingDiv;
    }
    
    function sendStreamRequest(messageId, loadingDiv) {
        debugLog("Starting stream request for message ID:", messageId);
        
        // Create EventSource URL with all parameters - simplified
        const eventSourceUrl = new URL('/stream', window.location.href);
        eventSourceUrl.searchParams.append('t', Date.now());
        eventSourceUrl.searchParams.append('game_id', currentGameId || '');
        eventSourceUrl.searchParams.append('message_id', messageId || '');
        
        debugLog("Stream URL:", eventSourceUrl.toString());
        
        // Create error recovery timeout
        let responseTimeout = setTimeout(() => {
            debugLog("Response timeout - closing connection");
            eventSource.close();
            const responseTextElem = loadingDiv.querySelector('[id^="response-text"]');
            if (responseTextElem) {
                responseTextElem.classList.remove('typing');
                const oldCursor = responseTextElem.querySelector('.cursor');
                if (oldCursor) oldCursor.remove();
                
                if (!responseTextElem.textContent) {
                    responseTextElem.textContent = "Response timeout. Please try again.";
                    loadingDiv.classList.add('error-message');
                }
            }
            
            isGenerating = false;
        }, 30000);
        
        // Create EventSource for streaming
        const eventSource = new EventSource(eventSourceUrl.toString());
        
        eventSource.onopen = function(e) {
            debugLog("EventSource connection opened");
        };
        
        // Handle incoming messages
        eventSource.onmessage = function(event) {
            try {
                debugLog("Received message chunk:", event.data.substring(0, 50) + "...");
                const data = JSON.parse(event.data);
                const responseTextElem = loadingDiv.querySelector('[id^="response-text"]');
                
                if (responseTextElem) {
                    // Handle content
                    const formattedContent = data.content.replace(/\\n/g, '\n');
                    
                    if (data.error === true) {
                        loadingDiv.classList.add('error-message');
                    }
                    
                    responseTextElem.classList.remove('typing');
                    
                    const oldCursor = responseTextElem.querySelector('.cursor');
                    if (oldCursor) oldCursor.remove();
                    
                    responseTextElem.textContent += formattedContent;
                    
                    const cursor = document.createElement('span');
                    cursor.className = 'cursor';
                    responseTextElem.appendChild(cursor);
                    
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                    
                    if (data.full) {
                        checkForPlayerNames(data.full);
                    }
                }
            } catch (e) {
                debugLog("Error parsing event data:", e);
            }
        };
        
        // Handle stream completion
        eventSource.addEventListener('done', function() {
            debugLog("Stream complete");
            clearTimeout(responseTimeout);
            
            const responseTextElem = loadingDiv.querySelector('[id^="response-text"]');
            if (responseTextElem) {
                const oldCursor = responseTextElem.querySelector('.cursor');
                if (oldCursor) oldCursor.remove();
            }
            
            eventSource.close();
            isGenerating = false;
        });
        
        // Handle errors
        eventSource.onerror = function(e) {
            debugLog("EventSource error:", e);
            clearTimeout(responseTimeout);
            
            try {
                const responseTextElem = loadingDiv.querySelector('[id^="response-text"]');
                if (responseTextElem) {
                    const oldCursor = responseTextElem.querySelector('.cursor');
                    if (oldCursor) oldCursor.remove();
                    responseTextElem.classList.remove('typing');
                    
                    if (!responseTextElem.textContent) {
                        loadingDiv.classList.add('error-message');
                        responseTextElem.textContent = "Connection error. Please try again.";
                    }
                }
                
                eventSource.close();
            } catch (err) {
                debugLog("Error handling EventSource error:", err);
            } finally {
                isGenerating = false;
            }
        };
    }
    
    // Improved message tracking to prevent duplicates
    function messageExists(role, content) {
        // Create a simple hash for the message
        const msgHash = `${role}-${content.substring(0, 50)}`;
        
        // Check if we've seen this message before
        if (processedMessageIds.has(msgHash)) {
            return true;
        }
        
        // Add to our set of processed messages
        processedMessageIds.add(msgHash);
        
        // Keep the set from growing too large
        if (processedMessageIds.size > 100) {
            // Convert to array, keep only the most recent 50
            const msgArray = Array.from(processedMessageIds);
            processedMessageIds.clear();
            for (let i = msgArray.length - 50; i < msgArray.length; i++) {
                if (i >= 0) processedMessageIds.add(msgArray[i]);
            }
        }
        
        return false;
    }
    
    // Improved addMessage with duplicate detection
    function addMessage(sender, text, isTypewriter = false, fromUpdate = false) {
        // Skip if this appears to be the current user's message that we already displayed
        if (fromUpdate && sender.toLowerCase() === (playerNames[1] || 'player 1').toLowerCase() && 
            text === lastSentMessage) {
            debugLog("Skipping duplicate recent message");
            return false;
        }
        
        // Check if this is a duplicate message
        const role = sender.toLowerCase() === 'dm' ? 'assistant' : 'user';
        if (messageExists(role, text)) {
            debugLog("Skipping duplicate message:", text.substring(0, 20) + "...");
            return false;
        }
        
        // Track the last message from this sender
        lastPlayerMessages[sender] = text;
        
        debugLog("Adding message from", sender, ":", text.substring(0, 30) + (text.length > 30 ? "..." : ""));
        
        // Create message element
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${sender.toLowerCase() === 'dm' ? 'dm-message' : 'player-message'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = `${sender.toUpperCase()}: `;
        nameSpan.style.fontWeight = 'bold';
        msgDiv.appendChild(nameSpan);
        
        // Add content span
        const contentSpan = document.createElement('span');
        contentSpan.className = 'message-content';
        contentSpan.textContent = text;
        msgDiv.appendChild(contentSpan);
        
        chatWindow.appendChild(msgDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        return true;
    }
    
    // Modified addSystemMessage with duplicate detection
    function addSystemMessage(text, fromUpdate = false) {
        // Check for duplicates
        if (messageExists('system', text)) {
            debugLog("Skipping duplicate system message");
            return;
        }
        
        debugLog("Adding system message:", text);
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message system-message';
        msgDiv.style.color = '#6272a4';
        msgDiv.style.fontStyle = 'italic';
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = "SYSTEM: ";
        nameSpan.style.fontWeight = 'bold';
        msgDiv.appendChild(nameSpan);
        
        const contentSpan = document.createElement('span');
        contentSpan.className = 'message-content';
        contentSpan.textContent = text;
        msgDiv.appendChild(contentSpan);
        
        chatWindow.appendChild(msgDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    
    // Modified sendMessage function
    function sendMessage(inputElement, playerNumber) {
        const userMessage = inputElement.value.trim();
        if (!userMessage) return;
        
        // Store this message to avoid duplicates when polling
        lastSentMessage = userMessage;
        
        if (isGenerating) {
            debugLog("Already generating, ignoring send");
            return;
        }
        
        // Validate game session
        if (!currentGameId) {
            debugLog("No game ID, creating new game");
            addSystemMessage("No active game session. Creating a new one...");
            createNewGame();
            setTimeout(() => {
                sendMessage(inputElement, playerNumber);
            }, 1500);
            return;
        }
        
        debugLog(`Sending message for Player ${playerNumber}:`, userMessage.substring(0, 30));
        
        // Set generating state
        isGenerating = true;
        
        // Extract name if first message or if player name not set
        const extractedName = extractName(userMessage);
        if (extractedName && !playerNames[playerNumber]) {
            updatePlayerLabel(playerNumber, extractedName);
            if (playerNumber === 1) {
                playerName = extractedName;
                awaitingName = false;
            }
        }
        
        // Get sender name
        const sender = playerNames[playerNumber] || `Player ${playerNumber}`;
        
        // Add user message to chat
        addMessage(sender, userMessage);
        
        // Clear input field
        inputElement.value = '';
        
        // Create loading indicator
        const loadingId = `typing-indicator-${Date.now()}`;
        const textId = `response-text-${Date.now()}`;
        const loadingDiv = createLoadingDivForDM(loadingId, textId);
        
        // Prepare player context
        const playerContext = {};
        Object.entries(playerNames).forEach(([num, name]) => {
            if (name) playerContext[num] = name;
        });
        
        // Send to server - simplified
        fetch('/chat', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ 
                message: userMessage,
                game_id: currentGameId,
                player_number: playerNumber,
                player_names: playerContext
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            debugLog("Message sent successfully, response:", data);
            if (data && data.message_id) {
                sendStreamRequest(data.message_id, loadingDiv);
            } else {
                throw new Error("Invalid response data");
            }
        })
        .catch(error => {
            debugLog('Error sending message:', error);
            
            if (loadingDiv && loadingDiv.parentNode) {
                const responseTextElem = loadingDiv.querySelector('[id^="response-text"]');
                if (responseTextElem) {
                    responseTextElem.textContent = "Error: " + error.message;
                    loadingDiv.classList.add('error-message');
                } else {
                    loadingDiv.remove();
                    addSystemMessage("Error: " + error.message);
                }
            } else {
                addSystemMessage("Error: Failed to send message. " + error.message);
            }
            
            isGenerating = false;
        });
        
        // Focus input field
        inputElement.focus();
    }
    
    function addSystemMessage(text, fromUpdate = false) {
        debugLog("Adding system message:", text);
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message system-message';
        msgDiv.style.color = '#6272a4';
        msgDiv.style.fontStyle = 'italic';
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = "SYSTEM: ";
        nameSpan.style.fontWeight = 'bold';
        msgDiv.appendChild(nameSpan);
        
        const contentSpan = document.createElement('span');
        contentSpan.className = 'message-content';
        contentSpan.textContent = text;
        msgDiv.appendChild(contentSpan);
        
        chatWindow.appendChild(msgDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    
    function addMessage(sender, text, isTypewriter = false, fromUpdate = false) {
        // Skip if this appears to be the current user's message that we already displayed
        // This prevents duplicating messages that are both sent and received via polling
        if (fromUpdate && sender.toLowerCase() === (playerNames[1] || 'player 1').toLowerCase() && 
            text === lastSentMessage) {
            debugLog("Skipping duplicate message", text.substring(0, 20) + "...");
            return;
        }
        
        debugLog("Adding message from", sender, ":", text.substring(0, 30) + (text.length > 30 ? "..." : ""));
        
        // Create message element
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${sender.toLowerCase() === 'dm' ? 'dm-message' : 'player-message'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = `${sender.toUpperCase()}: `;
        nameSpan.style.fontWeight = 'bold';
        msgDiv.appendChild(nameSpan);
        
        // Add content span
        const contentSpan = document.createElement('span');
        contentSpan.className = 'message-content';
        contentSpan.textContent = text;
        msgDiv.appendChild(contentSpan);
        
        chatWindow.appendChild(msgDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    
    function checkForPlayerNames(text) {
        // Look for "Player X is named Y" patterns for all players
        const nameRegex = /Player (\d+) is (?:now |)named ([A-Za-z]+)/gi;
        let match;
        
        while ((match = nameRegex.exec(text)) !== null) {
            const playerNum = parseInt(match[1]);
            const playerName = match[2];
            
            if (playerNum && playerName) {
                debugLog(`Found name for Player ${playerNum}: ${playerName}`);
                updatePlayerLabel(playerNum, playerName);
            }
        }
    }
    
    function extractName(input) {
        const namePatterns = [
            /my name is ([A-Za-z]+)/i,
            /i am ([A-Za-z]+)/i,
            /call me ([A-Za-z]+)/i,
            /name's ([A-Za-z]+)/i,
            /name is ([A-Za-z]+)/i,
            /^([A-Za-z]+)$/i  // Just a name by itself
        ];
        
        for (const pattern of namePatterns) {
            const match = input.match(pattern);
            if (match && match[1]) {
                return match[1];
            }
        }
        
        return null;
    }
    
    function extractNameFromDMResponse(response) {
        const namePatterns = [
            /so your name is ([A-Za-z]+)/i,
            /welcome, ([A-Za-z]+)/i,
            /hello, ([A-Za-z]+)/i
        ];
        
        for (const pattern of namePatterns) {
            const match = response.match(pattern);
            if (match && match[1]) {
                return match[1];
            }
        }
        
        return null;
    }
    
    // FIXED: Completely revamped new game button to properly reset everything
    newGameBtn.addEventListener('click', function() {
        debugLog("New game button clicked");
        
        // Confirm with the user
        if (confirm("Start a new game? This will clear your current adventure.")) {
            try {
                // Clear existing state
                currentGameId = null;
                localStorage.removeItem('currentGameId');
                
                // Reset UI and state
                chatWindow.innerHTML = '';
                isGenerating = false;
                awaitingName = true;
                playerName = null;
                seenMessages = new Set();
                
                // FIXED: Completely remove player names from localStorage
                localStorage.removeItem('playerNames');
                
                // FIXED: Create a brand new object instead of modifying existing one
                playerNames = { 1: null, 2: null };
                
                // FIXED: Reset all player labels back to default
                const player1Label = document.getElementById('player1-label');
                if (player1Label) {
                    player1Label.textContent = "Player 1:";
                }
                
                const player2Label = document.getElementById('player2-label');
                if (player2Label) {
                    player2Label.textContent = "Player 2:";
                }
                
                // Reset UI elements
                player2Container.classList.add('hidden');
                isMultiplayerActive = false;
                
                // Clear all additional players
                additionalPlayersContainer.innerHTML = '';
                
                // Reset next player number
                nextPlayerNumber = 3;
                
                // Clear processed message tracking
                processedMessageIds.clear();
                
                // Start completely fresh game
                createNewGame();
            } catch (err) {
                debugLog("Error creating new game:", err);
                addSystemMessage("Error: " + err.message);
            }
        }
    });
    
    // Improved displayMessages function to handle player names better
    function displayMessages(messages) {
        debugLog("Displaying messages from history:", messages.length);
        // Don't clear chat history, add to it
        // chatWindow.innerHTML = '';  // REMOVED: Don't clear existing messages on refresh
        
        // Skip if we already have messages in the chat window
        if (chatWindow.querySelectorAll('.message').length > 0) {
            debugLog("Chat window already has messages, skipping redisplay");
            return;
        }
        
        messages.forEach(msg => {
            if (msg.role === 'assistant') {
                // DM messages
                addMessage('DM', msg.content);
                
                // Check for player names in DM response
                checkForPlayerNames(msg.content);
                const extractedName = extractNameFromDMResponse(msg.content);
                if (extractedName) {
                    // Try to match this with a pending player name
                    if (!playerNames[1]) {
                        updatePlayerLabel(1, extractedName);
                    }
                }
            }
            else if (msg.role === 'user') {
                // Player messages - determine which player
                let playerNum = 1;
                if (msg.player && msg.player.startsWith('player')) {
                    playerNum = parseInt(msg.player.substring(6));
                }
                
                // Use the name if we have it
                const sender = playerNames[playerNum] || `Player ${playerNum}`;
                addMessage(sender, msg.content);
                
                // Extract name if present and not already set
                const extractedName = extractName(msg.content);
                if (extractedName && !playerNames[playerNum]) {
                    updatePlayerLabel(playerNum, extractedName);
                }
            }
            else if (msg.role === 'system') {
                // System messages
                addSystemMessage(msg.content);
            }
        });
        
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // Enhanced initialize function to restore player names
    function initialize() {
        debugLog("Initializing game");
        
        seenMessages.clear();
        isGenerating = false;
        
        // Restore player names to UI
        Object.entries(playerNames).forEach(([num, name]) => {
            if (name) {
                const labelElement = document.getElementById(`player${num}-label`);
                if (labelElement) {
                    labelElement.textContent = `${name}:`;
                }
            }
        });
        
        // Show Player 2 container if they have a name
        if (playerNames[2]) {
            player2Container.classList.remove('hidden');
            isMultiplayerActive = true;
        } else {
            player2Container.classList.add('hidden');
        }
        
        // Clear additional players and recreate if needed
        additionalPlayersContainer.innerHTML = '';
        
        // Recreate input fields for players 3+
        for (let i = 3; i < 10; i++) {
            if (playerNames[i]) {
                const newPlayerContainer = createPlayerInput(i);
                additionalPlayersContainer.appendChild(newPlayerContainer);
                
                // Update next player number if needed
                if (i >= nextPlayerNumber) {
                    nextPlayerNumber = i + 1;
                }
                
                isMultiplayerActive = true;
            }
        }
        
        if (!currentGameId) {
            debugLog("No game ID, creating new game");
            createNewGame();
            return;
        }
        
        // Load chat history
        fetch('/load_history', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ 
                game_id: currentGameId
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            debugLog("Loaded history:", data);
            
            if (!data.history || !Array.isArray(data.history)) {
                throw new Error("Invalid history data");
            }
            
            // Process history data
            displayMessages(data.history);
            
            // Ensure welcome message is displayed (add it if missing)
            ensureWelcomeMessage();
            
            // Store session info
            localStorage.setItem('currentGameId', currentGameId);
            
            // Set the initial message count for update checking
            lastMessageCount = data.history.length;
            
            // REMOVED: Don't check for updates at all
            // Neither polling nor one-time check
            
            // Focus input
            userInput.focus();
        })
        .catch(error => {
            debugLog('Error loading history:', error);
            
            // Create default welcome message
            chatWindow.innerHTML = '';
            addMessage('DM', "Hello adventurer! Let's begin your quest. What is your name?", false);
            
            // Focus input
            userInput.focus();
        });
    }

    function createNewGame() {
        debugLog("Creating new game");
        
        // Reset UI state
        chatWindow.innerHTML = '';
        isGenerating = false;
        
        // Reset player name
        playerNames[1] = null;
        
        // Create loading message
        addMessage('DM', 'Creating a new adventure for you...', false);
        
        // Request new game from server
        fetch('/new_game', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({})
        })
        .then(response => response.json())
        .then(data => {
            debugLog("New game created:", data);
            
            if (data.success && data.game_id) {
                currentGameId = data.game_id;
                
                // Store in local storage
                localStorage.setItem('currentGameId', currentGameId);
                
                // Clear loading message
                chatWindow.innerHTML = '';
                
                // Add welcome message - make sure this is displayed
                addMessage('DM', "Hello adventurer! Let's begin your quest. What is your name?", false);
                debugLog("Added welcome message for new game");
                
                // Reset message count
                lastMessageCount = 1; // Start with 1 for the welcome message
                
                // REMOVED: Don't start polling at all
                // startUpdatePolling();
                
                // Focus input field
                userInput.focus();
            } else {
                throw new Error("Failed to create new game");
            }
        })
        .catch(error => {
            debugLog("Error creating new game:", error);
            addSystemMessage("Error: " + error.message);
            
            // Add welcome message anyway so user can interact
            ensureWelcomeMessage();
        });
    }

    // Set up event handlers
    sendBtn.addEventListener('click', function() {
        sendMessage(userInput, 1);
    });
    
    userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !isGenerating) {
            sendMessage(userInput, 1);
        }
    });
    
    // Set up copy button functionality
    copyChatBtn.addEventListener('click', function() {
        const messages = Array.from(chatWindow.querySelectorAll('.message')).map(msg => {
            const sender = msg.querySelector('span').textContent;
            const content = msg.querySelector('.message-content').textContent;
            return `${sender} ${content}`;
        }).join('\n\n');
        
        navigator.clipboard.writeText(messages).then(() => {
            alert('Chat copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy chat: ', err);
            alert('Failed to copy chat');
        });
    });
    
    // Add these variables back
    let isMultiplayerActive = false;

    // Add this function to show Player 2
    function showPlayer2() {
        if (player2Container.classList.contains('hidden')) {
            player2Container.classList.remove('hidden');
            
            // Move the isMultiplayerActive flag set to after the API call completes
            // to prevent race conditions with other functions
            
            // Notify the DM about the new player
            addSystemMessage("Player 2 has joined the game. Please enter your name.");
            
            // Create loading div for DM's response
            const loadingDiv = createLoadingDivForDM('dm-welcome-player2', 'response-text-welcome-player2');
            
            // Notify DM
            isGenerating = true;
            fetch('/chat', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    message: `A new player has joined the game. Please welcome Player 2 and ask for their name.`,
                    game_id: currentGameId,
                    player_number: 'system',
                    is_system: true
                })
            })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                debugLog("Player 2 welcome response:", data);
                if (data && data.message_id) {
                    sendStreamRequest(data.message_id, loadingDiv);
                    // Only set multiplayer active after successful API response
                    isMultiplayerActive = true;
                } else {
                    throw new Error("Invalid response data");
                }
            })
            .catch(error => {
                debugLog('Error adding Player 2:', error);
                if (loadingDiv && loadingDiv.parentNode) loadingDiv.remove();
                addSystemMessage("Error adding Player 2: " + error.message);
                isGenerating = false;
            });
            
            // Focus the player 2 input box
            setTimeout(() => player2Input.focus(), 100);
        }
    }

    // Add click handler for Add Player button
    addPlayerBtn.addEventListener('click', function() {
        if (isGenerating) {
            return; // Don't add players while generating a response
        }
        
        if (player2Container.classList.contains('hidden')) {
            // First click should only show Player 2
            showPlayer2();
        } else {
            // Player 2 is already visible, add the next player
            addPlayer(nextPlayerNumber);
        }
    });

    // Add event listener for Player 2 send button
    sendPlayer2Btn.addEventListener('click', function() {
        sendMessage(player2Input, 2);
    });

    // Add event listener for Player 2 input
    player2Input.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !isGenerating) {
            sendMessage(player2Input, 2);
        }
    });

    // Add function to create dynamic player input for players 3+
    function createPlayerInput(playerNumber) {
        debugLog(`Creating input for Player ${playerNumber}`);
        const playerInputDiv = document.createElement('div');
        playerInputDiv.className = 'player-input';
        playerInputDiv.id = `player${playerNumber}-container`;
        
        const playerLabelDiv = document.createElement('div');
        playerLabelDiv.className = 'player-label';
        playerLabelDiv.id = `player${playerNumber}-label`;
        playerLabelDiv.textContent = `Player ${playerNumber}:`;
        
        const playerInput = document.createElement('input');
        playerInput.type = 'text';
        playerInput.id = `player${playerNumber}-input`;
        playerInput.placeholder = 'Type your message...';
        playerInput.autocomplete = 'off';
        playerInput.className = `player${playerNumber}-input`;
        
        // Add Enter key functionality
        playerInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !isGenerating) {
                sendMessage(playerInput, playerNumber);
            }
        });
        
        const sendButton = document.createElement('button');
        sendButton.className = 'action-btn send-btn';
        sendButton.id = `send-player${playerNumber}-btn`;
        sendButton.textContent = 'ðŸ“¤ Send';
        sendButton.title = 'Send message';
        
        // Add click handler to the button
        sendButton.addEventListener('click', function() {
            sendMessage(playerInput, playerNumber);
        });
        
        playerInputDiv.appendChild(playerLabelDiv);
        playerInputDiv.appendChild(playerInput);
        playerInputDiv.appendChild(sendButton);
        
        return playerInputDiv;
    }

    // Update showPlayer2 function to make it more generic
    function addPlayer(playerNum) {
        // Don't allow adding more players while generating
        if (isGenerating) {
            return;
        }
        
        // Don't allow adding Player 2 through this function - use showPlayer2() instead
        if (playerNum === 2) {
            if (player2Container.classList.contains('hidden')) {
                showPlayer2();
            }
            return;
        }
        
        // Create UI for the new player 3+
        const newPlayerContainer = createPlayerInput(playerNum);
        additionalPlayersContainer.appendChild(newPlayerContainer);
        
        // Reset this player's name
        playerNames[playerNum] = null;
        
        // Notify the DM about the new player
        const joinMessage = `Player ${playerNum} has joined the game. Please enter your name.`;
        addSystemMessage(joinMessage);
        
        // Create loading div for DM's response
        const loadingDiv = createLoadingDivForDM(
            `dm-welcome-player${playerNum}`, 
            `response-text-welcome-player${playerNum}`
        );
        
        // Notify DM
        isGenerating = true;
        fetch('/chat', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                message: `A new player has joined the game. Please welcome Player ${playerNum} and ask for their name.`,
                game_id: currentGameId,
                player_number: 'system',
                is_system: true
            })
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            debugLog(`Player ${playerNum} welcome response:`, data);
            if (data && data.message_id) {
                sendStreamRequest(data.message_id, loadingDiv);
                
                // Focus the new player's input field
                setTimeout(() => {
                    const inputField = document.getElementById(`player${playerNum}-input`);
                    if (inputField) inputField.focus();
                }, 100);
                
                // Update next player number
                if (playerNum >= nextPlayerNumber) {
                    nextPlayerNumber = playerNum + 1;
                }
            } else {
                throw new Error("Invalid response data");
            }
        })
        .catch(error => {
            debugLog(`Error adding Player ${playerNum}:`, error);
            if (loadingDiv && loadingDiv.parentNode) loadingDiv.remove();
            addSystemMessage(`Error adding Player ${playerNum}: ${error.message}`);
            isGenerating = false;
        });
    }

    // Update Add Player button to add the next player
    addPlayerBtn.addEventListener('click', function() {
        if (!isMultiplayerActive) {
            // First click adds player 2
            addPlayer(2);
        } else {
            // Subsequent clicks add player 3, 4, etc.
            addPlayer(nextPlayerNumber);
        }
    });

    // Add a function to check for updates
    function checkForUpdates() {
        if (!currentGameId || isCheckingForUpdates || isGenerating) {
            return; // Don't check if no game is active or already checking or AI is generating
        }
        
        isCheckingForUpdates = true;
        
        fetch('/get_updates', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                game_id: currentGameId,
                last_message_count: lastMessageCount
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Server returned ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.has_updates) {
                // Process new messages
                let newMessages = data.updates;
                let addedMessages = 0;
                
                // Append new messages to the chat window
                newMessages.forEach(msg => {
                    let wasAdded = false;
                    
                    if (msg.role === 'assistant') {
                        wasAdded = addMessage('DM', msg.content, false, true);
                        if (wasAdded) checkForPlayerNames(msg.content);
                    }
                    else if (msg.role === 'user') {
                        let playerNum = 1;
                        if (msg.player && msg.player.startsWith('player')) {
                            playerNum = parseInt(msg.player.substring(6));
                        }
                        
                        const sender = playerNames[playerNum] || `Player ${playerNum}`;
                        wasAdded = addMessage(sender, msg.content, false, true);
                    }
                    else if (msg.role === 'system') {
                        addSystemMessage(msg.content, true);
                        wasAdded = true;
                    }
                    
                    if (wasAdded) addedMessages++;
                });
                
                // Update the message count
                lastMessageCount = data.message_count;
                
                // Check if we need to show other players' inputs
                if (addedMessages > 0) {
                    checkForMissingPlayers(newMessages);
                }
            } else if (data.success) {
                // Update our message count if server has a different count
                if (data.message_count !== lastMessageCount) {
                    lastMessageCount = data.message_count;
                }
            }
        })
        .catch(error => {
            debugLog("Error checking for updates:", error);
        })
        .finally(() => {
            isCheckingForUpdates = false;
        });
    }

    // Add this function to check for missing player inputs
    function checkForMissingPlayers(messages) {
        // Find unique player numbers from messages
        const playerNumbers = new Set();
        
        messages.forEach(msg => {
            if (msg.player && msg.player.startsWith('player')) {
                const playerNum = parseInt(msg.player.substring(6));
                if (!isNaN(playerNum) && playerNum > 1) {  // Ignore player 1 (self)
                    playerNumbers.add(playerNum);
                }
            }
        });
        
        // For each player number, make sure their input is visible
        playerNumbers.forEach(playerNum => {
            if (playerNum === 2) {
                // Make sure player 2 input is visible
                if (player2Container.classList.contains('hidden')) {
                    player2Container.classList.remove('hidden');
                    isMultiplayerActive = true;
                }
            } 
            else if (playerNum >= 3) {
                // Check if we need to add input for player 3+
                const containerExists = document.getElementById(`player${playerNum}-container`);
                if (!containerExists) {
                    const newPlayerContainer = createPlayerInput(playerNum);
                    additionalPlayersContainer.appendChild(newPlayerContainer);
                    
                    // Update nextPlayerNumber if needed
                    if (playerNum >= nextPlayerNumber) {
                        nextPlayerNumber = playerNum + 1;
                    }
                    
                    isMultiplayerActive = true;
                }
            }
        });
    }

    // FIXED: Completely disable update polling
    function startUpdatePolling() {
        // Clear any existing interval
        if (updateCheckInterval) {
            clearInterval(updateCheckInterval);
            updateCheckInterval = null;
        }
        
        // REMOVED: Do NOT even check once - completely disable polling
        debugLog("Automatic polling is disabled");
    }

    // Initialize
    try {
        if (currentGameId) {
            debugLog("Restoring session:", currentGameId);
            initialize();
        } else {
            debugLog("No previous session, creating new game");
            createNewGame();
        }
        
        // Add a final check after small delay to ensure welcome message is displayed
        setTimeout(ensureWelcomeMessage, 500);
    } catch (error) {
        debugLog("Error during initialization:", error);
        // Add welcome message anyway as fallback
        ensureWelcomeMessage();
    }
});
</script>
</body>
</html>
